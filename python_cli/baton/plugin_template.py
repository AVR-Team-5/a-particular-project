TEMPLATE_NOTICE = """// Template file generated by Baton. Feel free to change it or remove this message."""

ADMINISTRATOR_TEMPLATE = TEMPLATE_NOTICE + """
using System.Threading.Tasks;
using Kari.GeneratorCore.Workflow;

namespace Kari.Plugins.{name}
{{
    // The plugin interface to Kari.
    // Kari will call methods of this class to analyze and then generate code.
    public class {name}Administrator : IAdministrator
    {{
        public {name}Analyzer[] _analyzers;
        
        // Called after all of the projects have been loaded
        public void Initialize()
        {{
            AnalyzerMaster.Initialize(ref _analyzers);

            var logger = new Logger("{name} Plugin");
            {name}Symbols.Initialize(logger);
        }}
        
        // Called when it is time to find ("collect") the types and methods you need to analyze.
        // At this stage, info objects are created and stored, 
        // containing the final data needed to generate the output.
        public Task Collect()
        {{
            return AnalyzerMaster.CollectAsync(_analyzers);
        }}

        // Called to generate code. The name of the files can be anything.
        public Task Generate()
        {{
            return Task.WhenAll(
                AnalyzerMaster.GenerateAsync(_analyzers, "From_{name}.cs", new {name}Template()),
                // Write the attributes to an acessible file.
                MasterEnvironment.Instance.CommonPseudoProject.WriteFileAsync("{name}Annotations.cs", GetAnnotations())
            );
        }}
        
        public string GetAnnotations() => Dummy{name}Annotations.Text;
    }}
}}
"""

ANALYZER_TEMPLATE = TEMPLATE_NOTICE + """
using System.Collections.Generic;
using Kari.GeneratorCore.Workflow;
using Microsoft.CodeAnalysis;

namespace Kari.Plugins.{name}
{{
    // An analyzer will be created per project. 
    // It manages collecting specific information with a single project as input.
    public class {name}Analyzer : IAnalyzer
    {{
        // Keep this public for it to be acessible via the template.
        public readonly List<{name}Info> _infos = new List<{name}Info>();

        public void Collect(ProjectEnvironment environment)
        {{
            foreach (var type in environment.TypesWithAttributes)
            {{
                if (type.HasAttribute({name}Symbols.{name}Attribute.symbol))
                {{
                    _infos.Add(new {name}Info(type));
                }}
            }}
        }}
    }}

    // Store information in such structs/classes
    public readonly struct {name}Info
    {{
        public readonly INamedTypeSymbol Symbol;

        public {name}Info(INamedTypeSymbol symbol)
        {{
            Symbol = symbol;
        }}
    }}
}}
"""

TEMPLATE_TEMPLATE = """<#@ template debug="false" hostspecific="false" linePragmas="false" language="C#" inherits="CodeGenerator<{name}Analyzer>" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="Kari.GeneratorCore" #>
<#@ import namespace="Kari.Plugins.{name}" #>
<#  // Returing null implies no output should be generated for the given template
    // `m` here is the analyzer instance for the current project.
    if (m._infos.Count == 0) return null;  #>

namespace <#= Project.GeneratedNamespace #>
{{
<#  // IMPORTANT: 
    // Put the usings inside the namespace, because Kari may do single-file output
    // in which case the generated code might be messed up if you pull in any symbols.
    // Try to scope things as much as possible and fully-qualify names where appropriate. #>
    using System;

    public static class MarkedTypes
    {{
<#  foreach (var info in m._infos)
    {{ #>
        public const string <#= info.Symbol.Name #> = "<#= info.Symbol.Name #>";
<#  }} #>
    }}
}}
"""

ANNOTATIONS_TEMPLATE = TEMPLATE_NOTICE + """
// This file should be included almost as-is in the generated output.
// The text version of this file and the helpers for the attributes defined here are available in the
// {name}Annotations.Generated.cs version of this file.
namespace Kari.Plugins.{name}
{{
    // It is important to import things inside the namespace.
    // Obviously, you cannot import Kari specific things or things defined in your other files, 
    // unless you also export the source code from those files.
    using System;
    using System.Diagnostics;

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    [Conditional("CodeGeneration")]
    public class {name}Attribute : Attribute
    {{
    }}

    // You may include things besides attributes in this file, 
    // if you want them shared between your and your consumer's project.
    public interface IExample
    {{
    }}
}}
"""

CSPROJ_TEMPLATE = """<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <AssemblyName>Kari.Plugins.{name}</AssemblyName>
  </PropertyGroup>

  <ImportGroup>
    <!-- See the plugin properties at `../Plugin.props` for more details -->
    <Import Project="$(PLUGIN_PROPS)" />
  </ImportGroup>
</Project>
"""

from baton.logger import log_error
import os, shutil

def write(plugins_directory : str, plugin_name : str, override = False) -> bool:
    plugin_directory = os.path.join(plugins_directory, plugin_name)
    
    if os.path.exists(plugin_directory):
        if not override:
            log_error(f"{plugin_directory} already exists")
            return False
        else:
            shutil.rmtree(plugin_directory)

    os.mkdir(plugin_directory)

    def _write_file(file, content):
        f = open(file, "w")
        f.write(content)
        f.close()
        
    def write_file(file_end : str, template : str, directory : str = plugin_directory):
        return _write_file(os.path.join(directory, f"{plugin_name}{file_end}"), template.format(name = plugin_name))

    write_file("Administrator.cs",  ADMINISTRATOR_TEMPLATE)
    write_file("Analyzer.cs",       ANALYZER_TEMPLATE)
    write_file("Annotations.cs",    ANNOTATIONS_TEMPLATE)
    write_file(".csproj",           CSPROJ_TEMPLATE)

    templates_path = os.path.join(plugin_directory, "Templates")
    os.mkdir(templates_path)
    write_file("Template.tt", TEMPLATE_TEMPLATE, directory=templates_path)
